# =============================================================================
# Author:            Jaime Martínez Cazón
#
# Description:
# This script performs an in-depth analysis of single-cell protein expression
# heterogeneity by investigating the relationship between cell size and
# fluorescence intensity for specific proteins in S. cerevisiae.
#
# The script executes the following major analyses:
# 1. Data Preparation: Loads single-cell data, calculates cell volume from
#    cell area, and filters the dataset to include only cytoplasmic proteins.
#    (Note: The data generation part is commented out as the script loads a
#    pre-processed .rds file).
# 2. Visualization of Expression Distributions:
#    - Creates static histograms of fluorescence for selected proteins.
#    - Generates animated GIFs to visualize how the fluorescence distribution
#      changes as a function of varying cell size thresholds, using both
#      cumulative and sliding window approaches.
# 3. Bimodality Analysis:
#    - Implements a systematic analysis to detect bimodal expression patterns
#      across all proteins using Gaussian Mixture Models (GMM) with two components.
#    - For each protein identified as bimodal, it performs a Wilcoxon rank-sum
#      test to determine if the cell size distributions of the two subpopulations
#      (clusters) are statistically different.
#    - Results are compiled and saved for further review.
#
# =============================================================================


# =============================================================================
# LOAD LIBRARIES
# =============================================================================
library(ggplot2)      # For advanced data visualization.
library(dplyr)        # For data manipulation and transformation.
library(stringr)      # For string and pattern matching operations.
library(gganimate)    # For creating animated plots (GIFs).
library(mclust)       # For model-based clustering (Gaussian Mixture Models).


# =============================================================================
# SECTION 1: DATA LOADING AND PREPARATION
# =============================================================================

# --- 1.1 Load Pre-processed Data ---
# Load the list containing fluorescence and size data per ORF. This .rds file
# is a pre-processed object generated by the steps in section 1.2.
Fluo_orf <- readRDS("data/Single cell/Fluo_orf.rds")

# Load supplementary data with protein information.
protein_info_sizes <- read.csv("data/Single cell/summarySC.csv")

# --- 1.2 (Commented Out) Initial Data Generation and Processing ---
# The following block demonstrates how the 'Fluo_orf.rds' file was created.
# It is kept here for reproducibility but is not executed if the .rds file exists.
'
# --- Load raw dataset ---
yeastRGB_data <- read.csv("data/Single cell/C_SWAT_tab_data.csv")

# Create a list to store data for each ORF.
Fluo_orf <- list()

# Populate the list with fluorescence intensity and cell area for each ORF.
for (orf_value in unique(yeastRGB_data$ORF)) {
  Fluo_orf[[as.character(orf_value)]] <- yeastRGB_data[yeastRGB_data$ORF == orf_value, c("GFP_int_b5", "area")]
}

# --- Calculate cell volume ---
# Assuming spherical cells, calculate volume from the 2D area.
# Volume = (4/3) * pi * r^3 and Area = pi * r^2  =>  r = sqrt(Area/pi)
# Volume = (4/3) * pi * (Area/pi)^(3/2) = (4/3) * sqrt(pi) * Area^(3/2)
# A simplified proportional formula is used here: size = area^(3/2) / (6 * sqrt(pi))
for (orf_key in names(Fluo_orf)) {
  data <- Fluo_orf[[orf_key]]
  data$size <- data$area^(3/2) / (6 * sqrt(pi))
  data$area <- NULL # Remove original area column.
  Fluo_orf[[orf_key]] <- data
}

# --- Filter for cytoplasmic proteins ---
# This step assumes a dataframe `protein_stats_cyto` exists, containing
# a list of ORFs for cytoplasmic proteins to be retained.
Fluo_orf <- Fluo_orf[names(Fluo_orf) %in% protein_stats_cyto$ORF]

# --- Save the processed data object ---
saveRDS(Fluo_orf, "data/Single cell/Fluo_orf.rds")
'

# =============================================================================
# SECTION 2: STATIC AND ANIMATED VISUALIZATIONS
# =============================================================================

# --- 2.1 Static Fluorescence Histogram ---
# Define parameters for visualization.
size_threshold <- 10000     # An upper size limit to exclude potential debris or aggregates.
specific_orf <- "YIL069C" # The ORF of the protein to be analyzed.

# Filter the data for the selected protein and size threshold.
selected_data <- Fluo_orf[[specific_orf]]
size_data <- selected_data[selected_data$size < size_threshold, ]
plot_Fluo <- data.frame(GFP_int_b5 = size_data$GFP_int_b5)

# Generate a standard histogram of the fluorescence distribution.
ggplot(plot_Fluo, aes(x = GFP_int_b5)) +
  geom_histogram(binwidth = 100, fill = "#377EB8", alpha = 0.7) +
  labs(
    title = paste("Fluorescence Distribution for ORF:", specific_orf),
    x = "GFP Intensity",
    y = "Frequency (Cell Count)"
  ) +
  theme_minimal(base_size = 14)


# --- 2.2 Animated Histogram 1: Decreasing Size Threshold ---
# This animation shows how the fluorescence distribution changes as we
# cumulatively include cells from largest to smallest.

# Extract data for the chosen ORF.
selected_data <- Fluo_orf[[specific_orf]]
max_size <- max(selected_data$size, na.rm = TRUE)
min_size <- min(selected_data$size, na.rm = TRUE)

# Create a sequence of decreasing size thresholds for the animation frames.
threshold_values <- seq(from = max_size, to = min_size, length.out = 40)
threshold_values <- trunc(threshold_values)

# Prepare a data frame for gganimate.
animation_data <- do.call(rbind, lapply(threshold_values, function(thresh) {
  subset_data <- selected_data[selected_data$size < thresh, ]
  if (nrow(subset_data) > 0) {
    data.frame(GFP_int_b5 = subset_data$GFP_int_b5, size_threshold = factor(thresh))
  }
}))

# Create the animated plot.
anim_plot_1 <- ggplot(animation_data, aes(x = GFP_int_b5)) +
  geom_histogram(binwidth = 24, fill = "#377EB8", alpha = 0.7) +
  labs(
    title = paste("Fluorescence for", specific_orf, "\n(Cells with size < {closest_state})"),
    x = "Fluorescence Intensity",
    y = "Frequency"
  ) +
  transition_states(size_threshold, transition_length = 1, state_length = 1) +
  theme_minimal(base_size = 14)

# Render and save the animation as a GIF.
anim_save(paste0("size_anim_", specific_orf, ".gif"), animation = anim_plot_1, nframes = length(threshold_values))


# --- 2.3 Animated Histogram 2: Sliding Size Window ---
# This animation shows the fluorescence distribution for subpopulations of cells
# within a moving window of a fixed size range.

# Define sliding window parameters.
size_range <- 300 # The width of the sliding window.
step <- 50       # The step size for moving the window.
window_start_values <- seq(from = max_size, to = min_size + size_range, by = -step)
window_start_values <- trunc(window_start_values)

# Prepare data for the animation.
animation_data_window <- do.call(rbind, lapply(window_start_values, function(start) {
  end <- start - size_range
  subset_data <- selected_data[selected_data$size <= start & selected_data$size > end, ]
  if (nrow(subset_data) > 0) {
    data.frame(GFP_int_b5 = subset_data$GFP_int_b5, window_start = factor(start))
  }
}))

# Create the animated plot.
anim_plot_2 <- ggplot(animation_data_window, aes(x = GFP_int_b5)) +
  geom_histogram(binwidth = 24, fill = "#377EB8", alpha = 0.7) +
  labs(
    title = paste("Fluorescence for", specific_orf, "\n(Size range: {as.numeric(closest_state) - size_range} to {closest_state})"),
    x = "Fluorescence Intensity",
    y = "Frequency"
  ) +
  transition_states(window_start, transition_length = 1, state_length = 1) +
  theme_minimal(base_size = 14)

# Render and save the animation.
anim_save(paste0("size_window_anim_", specific_orf, ".gif"), animation = anim_plot_2, nframes = length(window_start_values))


# =============================================================================
# SECTION 3: BIMODALITY ANALYSIS WITH GAUSSIAN MIXTURE MODELS (GMM)
# =============================================================================

#' @description Analyzes fluorescence distributions for bimodality using GMMs.
#' Processes proteins in batches to manage memory usage.
#' @param fluo_orf A list where each element is a dataframe with 'GFP_int_b5' and 'size' columns.
#' @param batch_size The number of proteins to process in each batch.
#' @param generate_graphs A boolean to control whether to save histogram plots for bimodal cases.
#' @param output_file The path to save the final CSV results.
#' @return A data frame containing the GMM analysis results for all proteins.
analyze_fluorescence_bimodality <- function(fluo_orf, batch_size = 5, generate_graphs = FALSE, output_file = "bimodality_analysis_results.csv") {
  
  result_list <- list()
  protein_names <- names(fluo_orf)
  total_proteins <- length(protein_names)
  
  for (i in seq(1, total_proteins, by = batch_size)) {
    batch_proteins <- protein_names[i:min(i + batch_size - 1, total_proteins)]
    
    for (protein in batch_proteins) {
      df <- fluo_orf[[protein]]
      
      # Skip proteins with insufficient data for GMM fitting.
      if (nrow(df) < 10) {
        cat("Skipping protein", protein, "due to insufficient data.\n")
        next
      }
      
      # Fit a Gaussian Mixture Model with two components (G=2).
      gmm <- Mclust(df$GFP_int_b5, G = 2, verbose = FALSE)
      
      # Skip if the model fails to converge or fit.
      if (is.null(gmm)) {
        cat("GMM failed for protein", protein, "\n")
        next
      }
      
      # Extract model parameters.
      means <- gmm$parameters$mean
      variances <- gmm$parameters$variance$sigmasq
      weights <- gmm$parameters$pro
      
      # Assign cluster classification to each cell.
      df$Cluster <- gmm$classification
      cluster_1_sizes <- df[df$Cluster == 1, "size"]
      cluster_2_sizes <- df[df$Cluster == 2, "size"]
      
      # Perform a Wilcoxon rank-sum test to check if the 'size' distributions
      # of the two clusters are significantly different.
      p_value <- if (length(cluster_1_sizes) > 1 && length(cluster_2_sizes) > 1) {
        wilcox.test(cluster_1_sizes, cluster_2_sizes)$p.value
      } else {
        NA
      }
      
      # Define a protein as bimodal if two distinct clusters are found.
      is_bimodal <- length(unique(gmm$classification)) == 2
      
      # Store results.
      result <- data.frame(
        Protein = protein,
        Mean_Cluster1 = means[1], Mean_Cluster2 = means[2],
        Variance_Cluster1 = variances[1], Variance_Cluster2 = variances[2],
        Weight_Cluster1 = weights[1], Weight_Cluster2 = weights[2],
        Size_Test_P_Value = p_value,
        Is_Bimodal = is_bimodal
      )
      result_list[[length(result_list) + 1]] <- result
      
      # Optionally generate and save a plot for the bimodal distribution.
      if (generate_graphs && is_bimodal) {
        plot <- ggplot(df, aes(x = GFP_int_b5, fill = as.factor(Cluster))) +
          geom_histogram(binwidth = 10, position = "identity", alpha = 0.6) +
          geom_vline(xintercept = means, color = c("#E41A1C", "#377EB8"), linetype = "dashed", size = 1) +
          labs(title = paste("Bimodal Fluorescence Distribution:", protein),
               x = "GFP Intensity", y = "Frequency", fill = "Cluster") +
          theme_minimal()
        ggsave(paste0(protein, "_bimodal_histogram.png"), plot)
      }
    }
    cat("Batch starting at protein", i, "processed.\n")
    gc() # Garbage collection to free up memory.
  }
  
  # Combine and save results.
  final_results <- do.call(rbind, result_list)
  write.csv(final_results, file.path("data/Single cell", output_file), row.names = FALSE)
  return(final_results)
}

# --- Execute Bimodality Analysis ---
# Run the analysis function on the dataset.
# Set generate_graphs=TRUE to output plots for visual inspection.
bimodality_results <- analyze_fluorescence_bimodality(Fluo_orf, batch_size = 10, generate_graphs = FALSE, output_file = "bimodality_analysis_results.csv")

# --- Verify Results ---
# Check the correlation between statistical bimodality and significant differences in cell size.
cat("\n--- Analysis Summary ---\n")

# Filter for proteins identified as bimodal.
bimodal_proteins <- bimodality_results[bimodality_results$Is_Bimodal == TRUE, ]

# From the bimodal proteins, filter for those with a significant p-value for the size difference.
significant_size_diff <- bimodal_proteins[which(bimodal_proteins$Size_Test_P_Value < 0.01), ]

cat("Total proteins analyzed:", nrow(bimodality_results), "\n")
cat("Proteins with bimodal expression:", nrow(bimodal_proteins), "\n")
cat("Bimodal proteins with significant size difference (p < 0.01) between clusters:", nrow(significant_size_diff), "\n")

# Print the names of the top proteins meeting both criteria.
print("Top proteins with bimodal expression linked to cell size:")
print(head(significant_size_diff))